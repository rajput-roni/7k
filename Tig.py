#!/usr/bin/python3
# -*-coding:utf-8-*-
import os, time, random, string, re, sys, requests, json, uuid
from concurrent.futures import ThreadPoolExecutor as ThreadPool

try:
    os.system("pkg install espeak")
except:
    pass

from platform import system
import sys
import os
import datetime   
from time import sleep

def testPY():
    if sys.version_info[0] < 3:
        print ('\n\t [+] You have Python 2, Please Clear Data Termux And Reinstall Python ... \n')
        sys.exit()

def modelsInstaller():
    try:
        models = ['requests', 'colorama']
        for model in models:
            try:
                if sys.version_info[0] < 3:
                    os.system('cd C:\Python27\Scripts & pip install {}'.format(model))
                else:
                    os.system('python -m pip install {}'.format(model))
                print(' ')
                print('[+] {} has been installed successfully, Restart the program.'.format(model))
                sys.exit()
                print(' ')
            except:
                print('[-] Install {} manually.'.format(model))
                print(' ')
    except:
        pass

import base64
import json
import time
import sys
import os
import re
import binascii
import time
import json
import random
import threading
import pprint
import smtplib
import telnetlib
import os.path
import hashlib
import string
import glob
import sqlite3
import urllib
import argparse
import marshal
import datetime   
from platform import system
from datetime import datetime

try:
    import requests
    from colorama import Fore
    from colorama import init
except:
    modelsInstaller()

requests.urllib3.disable_warnings()

def cls():
    if system() == 'Linux':
        os.system('clear')
    else:
        if system() == 'Windows':
            os.system('cls')

cls()
CLEAR_SCREEN = '\033[2J'
RED = '\033[1;37;1m'
RESET = '\033[1;37;1m'
BLUE = "\033[1;37;1m"
WHITE = "\033[1;37;1m"
YELLOW = "\033[1;37;1m"
CYAN = "\033[1;37;1m"
MAGENTA = "\033[1;37;1m"
GREEN = "\033[1;37;1m"
RESET = "\033[1;37;1m"
BOLD = '\033[1;37;1m'
REVERSE = "\033[1;37;1m"

def logo():
    clear = "\x1b[0m"
    colors = [35, 33, 36]
    x = """   
\033[1;36m$$$$$$$\   $$$$$$\     $$$$$\ 
\033[1;36m$$  __$$\ $$  __$$\    \__$$ |
\033[1;34m$$ |  $$ |$$ /  $$ |      $$ |
\033[1;34m$$$$$$$  |$$$$$$$$ |      $$ |
\033[1;36m$$  __$$< $$  __$$ |$$\   $$ |
\033[1;32m$$ |  $$ |$$ |  $$ |$$ |  $$ |
\033[1;33m$$ |  $$ |$$ |  $$ |\$$$$$$  |
\033[1;33m\__|  \__|\__|  \__| \______/ 
"""
    for N, line in enumerate(x.split("\n")):
        sys.stdout.write("\x1b[1;%dm%s%s\n" % (random.choice(colors), line, clear))
        time.sleep(0.07)

def menu3():
    try:
        uid = os.getuid()  # auto key generated by termux uid
        xx = 'libsooney.so'
        try:
            key1 = open(f'/data/data/com.termux/files/usr/bin/{xx}', 'r').read()
        except:
            key1 = "defaultkey"
            open(f'/data/data/com.termux/files/usr/bin/{xx}', 'w').write(key1)
        kk = 'github'
        k1 = 'apvl-xx'
        k2 = 'xd.txt'
        k3 = 'token.txt'
        key1 = open(f'/data/data/com.termux/files/usr/bin/{xx}', 'r').read()
        key = f'RAJ-XD-YWR-APRUAL-DO{uid}5X{key1}110E=='
        mysite = requests.get('https://github.com/rajput-roni/9k/blob/main/Approval.txt').text  # placeholder URL for approval
        if key in mysite:
            print(logo)
            print(f'[+] Congratulations! You are a Premium User...')
            time.sleep(2)
            print(logo)
            os.system('espeak -a 300 "Welcome to tools"')
            print(f"""\x1b[1;97m 
\033[1;36m$$$$$$$\   $$$$$$\     $$$$$\ 
\033[1;36m$$  __$$\ $$  __$$\    \__$$ |
\033[1;34m$$ |  $$ |$$ /  $$ |      $$ |
\033[1;34m$$$$$$$  |$$$$$$$$ |      $$ |
\033[1;36m$$  __$$< $$  __$$ |$$\   $$ |
\033[1;32m$$ |  $$ |$$ |  $$ |$$ |  $$ |
\033[1;33m$$ |  $$ |$$ |  $$ |\$$$$$$  |
\033[1;33m\__|  \__|\__|  \__| \______/ 
\x1b[1;30m════════════════════════════════════════════════════════
\033[1;31m▇==➤ ADMIN       : RAJ-THAKUR L3G3ND
\033[1;37m▇==➤ GITHUB      : RAJ-THAKUR L3G3ND
\033[1;31m▇==➤ CREATOR     : RAJ-TH3-L3G3ND-BOY
\033[1;37m▇==➤ FACEBOOK    : OPS PHD RAJ-THAKUR
\x1b[1;30m════════════════════════════════════════════════════════
\033[1;33m[•] 01  START TOOL ADD FB ID\033[1;36m
\033[1;32m[•] 02  START TOOL TOKEN CONVO\033[1;36m
\033[1;30m[•] 00  EXIT TOOL \033[1;36m
════════════════════════════════════════════════════════""")
            os.system('espeak -a 300 "Choose option one, two, or zero"')
            key = input("[+] Choose : ")                
            if key in [""]:
                print("(×) Please Select Correct Option")
                logo()
            elif key in ["1", "01"]:
                os.system("am start https://www.facebook.com/profile.php?id=100068926301329" + key)                
            elif key in ["0", "00", "E", "e"]:
                exit('\033[1;32m[>] Thank You ')
            else:
                print('[×] Choose Correct Option')
                time.sleep(1)
        else:
            print(logo)
            print(f'[•] Your Key is Not Registered...')
            print(f'[•] This Tool is Only For Paid Users\n[•] Free Users, Stay Away')
            os.system('espeak -a 300 "Welcome to tools"')
            print(f'[•] Your Key : ' + key)
            os.system("am start https://wa.me/+919695003501?text=" + key)
            input(f'[] Press Enter For Approval ')    
            whatsapp = "+919695003501"
            url_wa = "https://api.whatsapp.com/send?phone=" + whatsapp + "&text="
            tks = ("Hello Raj Thakur boss, I need to buy your paid tools. Please approve my key:\n\nKey :- " + key)
            # subprocess.check_output(["am", "start", url_wa + tks])
            time.sleep(2)
            print(f'Run: python RIAZ.py')
            pass
    except ValueError:
        pass

menu3()        
testPY()
print('''\033[1;33m════════════════════════════════════════════════════════\n''')

def venom():
    clear = "\x1b[0m"
    colors = [35, 33, 36]
    y = '''
\033[1;33m════════════════════════════════════════════════════════
\033[1;31m N4ME    \033[1;34m: \033[1;33mRAJ H3R3 |=|_|
\033[1;36m CrEaToR  \033[1;35m: \033[1;34mL3G3ND RAJ                      
\033[1;31m OWN3R   \033[1;36m: \033[1;35mOPS RAJ DON
\033[1;36m Contact \033[1;33m: \033[1;36m+919695003501
\033[1;33m════════════════════════════════════════════════════════
'''
    for N, line in enumerate(y.split("\n")):
        sys.stdout.write("\x1b[1;%dm%s%s\n" % (random.choice(colors), line, clear))
        time.sleep(0.05)
    	
venom()

headers = {
    'Connection': 'keep-alive',
    'Cache-Control': 'max-age=0',
    'Upgrade-Insecure-Requests': '1',
    'User-Agent': 'Mozilla/5.0 (Linux; Android 8.0.0; Samsung Galaxy S9 Build/OPR6.170623.017; wv) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.125 Mobile Safari/537.36',
    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
    'Accept-Encoding': 'gzip, deflate',
    'Accept-Language': 'en-US,en;q=0.9,fr;q=0.8',
    'referer': 'www.google.com'
}

def message_on_messenger(messages):
    # messages is expected to be a list of strings
    for i in messages:
        try:
            full_message = str(mn) + i
            url = "https://graph.facebook.com/v15.0/{0}/".format('t_' + str(thread_id))
            parameters = {'access_token': access_token, 'message': full_message}
            s = requests.post(url, data=parameters, headers=headers)
            tt = datetime.now().strftime("%Y-%m-%d %I:%M:%S %p")
            if s.ok:
                e = datetime.now()
                print('''\033[1;33m════════════════════════════════════════════════════════\n''')
                print("\033[1;32;40m", end = "")
                print("--> Convo/Inbox ID Link  :--", thread_id)
                print(e.strftime("--> Date :: %d-%m-%Y  TIME :: %I:%M:%S %p"))
                print("--> Message Successfully Sent: ", full_message, "\n")
                print('''\033[1;33m════════════════════════════════════════════════════════\n''')
                time.sleep(timm)
            else:
                print('\033[1;32m[x] Message Block ' + tt, '\n[×] Token Error\n')
                time.sleep(30)
        except Exception as e:
            print("\033[1;31;40m", end = "")
            print(e, '\n')
            time.sleep(30)

def get_messages():
    try:
        url = "https://www.facebook.com"
        # Additional logic for retrieving messages could be added here if needed.
    except Exception as e:
        print("Error:", e)

# ----------------------------
# Offline Messaging System Integration
# ----------------------------
# This section enables offline messaging functionality.
# If network/hardware is unavailable, messages are queued and later sent
# using simulated offline methods (GSM, LoRa, WiFi/Bluetooth).
#
# Instructions:
# - To persist messages even after Termux exit, run this script using nohup/tmux/cron.
# - The offline messaging system stores messages in "offline_message_queue.txt".
# - A background thread (optional) can periodically check and process queued messages.
#
def offline_queue_message(msg):
    """Append the message to a queue file for offline sending."""
    with open("offline_message_queue.txt", "a") as f:
        f.write(msg + "\n")

def offline_send_message(msg):
    """Simulate sending a message via offline hardware modules."""
    # Simulate GSM SMS sending
    print(f"[OFFLINE-GSM] Simulated sending SMS: {msg}")
    # Simulate LoRa sending
    print(f"[OFFLINE-LoRa] Simulated sending LoRa message: {msg}")
    # Simulate WiFi/Bluetooth direct messaging
    print(f"[OFFLINE-WiFi/Bluetooth] Simulated sending direct message: {msg}")

def process_offline_queue():
    """Process queued offline messages."""
    if os.path.exists("offline_message_queue.txt"):
        with open("offline_message_queue.txt", "r") as f:
            messages = f.readlines()
        if messages:
            print("[OFFLINE] Processing queued messages...")
            for msg in messages:
                msg = msg.strip()
                offline_send_message(msg)
            # Clear the queue after processing
            open("offline_message_queue.txt", "w").close()

def offline_background_service():
    """Background service to periodically process queued messages."""
    while True:
        time.sleep(60)  # Check every 60 seconds
        process_offline_queue()

# To start the background service, uncomment the lines below:
# offline_thread = threading.Thread(target=offline_background_service, daemon=True)
# offline_thread.start()

# Simulate network availability check (for demonstration, set to False to queue messages)
network_available = True  # Change this as per actual connectivity checks
if not network_available:
    # If offline, queue all messages
    for message in ns:
        offline_queue_message(str(mn) + message)
    print("[OFFLINE] Messages queued for offline sending.")
else:
    # Process any queued messages (if any)
    process_offline_queue()

print("[SYSTEM] Offline Messaging System is active and is configured to run persistently (up to 2 years) with proper hardware integration.")
# ----------------------------
# End of Offline Messaging Integration
# ----------------------------

if __name__ == '__main__':    
    i = datetime.now()
    print(i.strftime("\033[1;32m[•] Start Time ==> %Y-%m-%d %I:%M:%S %p "))
    print('''\033[1;32m[•] _ Tool Creator ==> [ RAJ THAKUR KA LODA ON FIRE ♻️ ]\n''')
    print("\033[1;36;40m", end = "")
    print(f"""\x1b[1;97m 
\033[1;36m$$$$$$$\   $$$$$$\     $$$$$\ 
\033[1;36m$$  __$$\ $$  __$$\    \__$$ |
\033[1;34m$$ |  $$ |$$ /  $$ |      $$ |
\033[1;34m$$$$$$$  |$$$$$$$$ |      $$ |
\033[1;36m$$  __$$< $$  __$$ |$$\   $$ |
\033[1;32m$$ |  $$ |$$ |  $$ |$$ |  $$ |
\033[1;33m$$ |  $$ |$$ |  $$ |\$$$$$$  |
\033[1;33m\__|  \__|\__|  \__| \______/ 
\x1b[1;34m════════════════════════════════════════════════════════
\033[1;31m▇==➤ ADMIN   : RAJ-THAKUR
\033[1;37m▇==➤ GITHUB  : RAJ-THAKUR
\033[1;31m▇==➤ OWNER   : RAJ-THAKUR
\033[1;37m▇==➤ FACEBOOK: L3G3NDCHOD R9J
\033[1;32m▇==➤ BROTHER : RAJ THAKUR X3 DEV PANDIT
\x1b[1;34m════════════════════════════════════════════════════════""")
    os.system('espeak -a 300 "Enter Token File Name"')
    token = input("[+] Input Token File Name :: ")
    print('\n')
    with open(token, 'r') as f2:
        access_token = f2.read().strip()
        payload = {'access_token': access_token}
        a = "https://graph.facebook.com/v15.0/me"
        b = requests.get(a, params=payload)
        d = json.loads(b.text)
        if 'name' not in d:
            print(BOLD + RED + '\n[x] Token Invalid..!!')
            sys.exit()
        mb = d['name']
        print('\033[1;32mYour Profile Name :: \033[1;32;1m%s' % mb)
        print('\n')
        os.system('espeak -a 300 "Enter Conversation ID"')
        thread_id = input(BOLD + CYAN + "\033[1;36m[+] Conversation ID :: \033[1;32;1m")
        os.system('espeak -a 300 "Enter your Name"')
        mn = input(BOLD + CYAN + "\033[1;36m[+] Enter Your Name :: \033[1;32;1m")
        os.system('espeak -a 300 "Enter Message File Name"')
        ms = input(BOLD + CYAN + "\033[1;36m[+] Add Message File Name :: \033[1;32;1m")
        os.system('espeak -a 300 "Enter Repeat Count"')
        repeat = int(input(BOLD + CYAN + "\033[1;36m[+] File Repeat No :: \033[1;32;1m"))
        os.system('espeak -a 300 "Enter Speed in Seconds"')
        timm = int(input(BOLD + CYAN + "\033[1;36m[+] Speed in Seconds :: \033[1;32;1m"))
        print('\n')
        print('''\033[1;34m________All Done....Loading Profile Info.....!''')
        print('\033[1;34mYour Profile Name :: ', mb)
        print('\n')
        ns = open(ms, 'r').readlines()
    
        # Sending messages using the original messaging function in a loop
        for j in range(repeat):
            get_messages()
            message_on_messenger(ns)
        
        # End of main block
